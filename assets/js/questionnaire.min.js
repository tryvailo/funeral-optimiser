/* ============================================
   CLEARFUNERALCOSTS - QUESTIONNAIRE FUNCTIONALITY
   Функциональность для анкеты
   ============================================ */

/**
 * Questionnaire Module - Handles multi-step form functionality
 */
class QuestionnaireModule {
    constructor() {
        this.currentStep = 1;
        this.totalSteps = 3;
        this.formData = {};
        this.isSubmitting = false;
        
        this.init();
    }

    /**
     * Initialize questionnaire functionality
     */
    init() {
        this.setupProgressIndicator();
        this.setupFormSteps();
        this.setupNavigation();
        this.setupFormValidation();
        this.setupDataPersistence();
        this.setupLegalDisclaimer();
    }

    /**
     * Setup progress indicator
     */
    setupProgressIndicator() {
        this.updateProgressBar();
        this.updateProgressText();
    }

    /**
     * Update progress bar
     */
    updateProgressBar() {
        const progressFill = document.querySelector('.progress-fill');
        if (!progressFill) return;

        const progressPercentage = (this.currentStep / this.totalSteps) * 100;
        progressFill.style.width = `${progressPercentage}%`;
    }

    /**
     * Update progress text
     */
    updateProgressText() {
        const progressText = document.querySelector('.progress-text');
        if (!progressText) return;

        progressText.textContent = `Step ${this.currentStep} of ${this.totalSteps}`;
    }

    /**
     * Setup form steps
     */
    setupFormSteps() {
        this.showStep(this.currentStep);
        this.setupStepValidation();
    }

    /**
     * Show specific step
     */
    showStep(stepNumber) {
        // Hide all steps
        const steps = document.querySelectorAll('.step');
        steps.forEach(step => {
            step.classList.remove('active');
        });

        // Show current step
        const currentStepElement = document.querySelector(`.step:nth-child(${stepNumber})`);
        if (currentStepElement) {
            currentStepElement.classList.add('active');
        }

        // Update progress
        this.updateProgressBar();
        this.updateProgressText();

        // Focus first input in current step
        const firstInput = currentStepElement?.querySelector('input, select, textarea');
        if (firstInput) {
            setTimeout(() => firstInput.focus(), 100);
        }
    }

    /**
     * Setup step validation
     */
    setupStepValidation() {
        const steps = document.querySelectorAll('.step');
        steps.forEach((step, index) => {
            const inputs = step.querySelectorAll('input[required], select[required], textarea[required]');
            inputs.forEach(input => {
                input.addEventListener('blur', () => this.validateStep(index + 1));
                input.addEventListener('input', () => this.clearStepErrors(index + 1));
            });
        });
    }

    /**
     * Validate specific step
     */
    validateStep(stepNumber) {
        const stepElement = document.querySelector(`.step:nth-child(${stepNumber})`);
        if (!stepElement) return true;

        const requiredInputs = stepElement.querySelectorAll('input[required], select[required], textarea[required]');
        let isValid = true;

        requiredInputs.forEach(input => {
            if (!this.validateField(input)) {
                isValid = false;
            }
        });

        return isValid;
    }

    /**
     * Clear step errors
     */
    clearStepErrors(stepNumber) {
        const stepElement = document.querySelector(`.step:nth-child(${stepNumber})`);
        if (!stepElement) return;

        const errorMessages = stepElement.querySelectorAll('.error-message');
        errorMessages.forEach(error => error.remove());

        const errorInputs = stepElement.querySelectorAll('.error');
        errorInputs.forEach(input => input.classList.remove('error'));
    }

    /**
     * Validate individual field
     */
    validateField(field) {
        const value = field.value.trim();
        const fieldName = field.name;
        let isValid = true;
        let errorMessage = '';

        // Remove existing error
        this.clearFieldError(field);

        // Validation rules
        switch (fieldName) {
            case 'serviceType':
                if (!value) {
                    isValid = false;
                    errorMessage = 'Please select a service type';
                }
                break;
            case 'location':
                const postcodeRegex = /^[A-Z]{1,2}[0-9][A-Z0-9]? [0-9][A-Z]{2}$/i;
                if (!postcodeRegex.test(value)) {
                    isValid = false;
                    errorMessage = 'Please enter a valid UK postcode';
                }
                break;
            case 'budgetRange':
                if (!value) {
                    isValid = false;
                    errorMessage = 'Please select a budget range';
                }
                break;
            case 'email':
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(value)) {
                    isValid = false;
                    errorMessage = 'Please enter a valid email address';
                }
                break;
            case 'contactPreference':
                if (!value) {
                    isValid = false;
                    errorMessage = 'Please select a contact preference';
                }
                break;
            case 'urgency':
                if (!value) {
                    isValid = false;
                    errorMessage = 'Please select urgency level';
                }
                break;
        }

        if (!isValid) {
            this.showFieldError(field, errorMessage);
        }

        return isValid;
    }

    /**
     * Show field error
     */
    showFieldError(field, message) {
        field.classList.add('error');
        
        let errorElement = field.parentNode.querySelector('.error-message');
        if (!errorElement) {
            errorElement = document.createElement('div');
            errorElement.className = 'error-message';
            field.parentNode.appendChild(errorElement);
        }
        errorElement.textContent = message;
    }

    /**
     * Clear field error
     */
    clearFieldError(field) {
        field.classList.remove('error');
        const errorElement = field.parentNode.querySelector('.error-message');
        if (errorElement) {
            errorElement.remove();
        }
    }

    /**
     * Setup navigation
     */
    setupNavigation() {
        this.setupNextButton();
        this.setupPrevButton();
        this.setupSubmitButton();
    }

    /**
     * Setup next button
     */
    setupNextButton() {
        const nextButton = document.querySelector('.nav-button.next');
        if (!nextButton) return;

        nextButton.addEventListener('click', (e) => {
            e.preventDefault();
            this.goToNextStep();
        });
    }

    /**
     * Setup previous button
     */
    setupPrevButton() {
        const prevButton = document.querySelector('.nav-button.prev');
        if (!prevButton) return;

        prevButton.addEventListener('click', (e) => {
            e.preventDefault();
            this.goToPrevStep();
        });
    }

    /**
     * Setup submit button
     */
    setupSubmitButton() {
        const submitButton = document.querySelector('.nav-button.next[type="submit"]');
        if (!submitButton) return;

        submitButton.addEventListener('click', (e) => {
            e.preventDefault();
            this.handleSubmit();
        });
    }

    /**
     * Go to next step
     */
    goToNextStep() {
        if (this.currentStep >= this.totalSteps) return;

        // Validate current step
        if (!this.validateStep(this.currentStep)) {
            this.showStepError('Please complete all required fields');
            return;
        }

        // Save current step data
        this.saveStepData(this.currentStep);

        // Move to next step
        this.currentStep++;
        this.showStep(this.currentStep);

        // Update navigation buttons
        this.updateNavigationButtons();

        // Track step completion
        this.trackStepCompletion(this.currentStep - 1);
    }

    /**
     * Go to previous step
     */
    goToPrevStep() {
        if (this.currentStep <= 1) return;

        // Save current step data
        this.saveStepData(this.currentStep);

        // Move to previous step
        this.currentStep--;
        this.showStep(this.currentStep);

        // Update navigation buttons
        this.updateNavigationButtons();
    }

    /**
     * Update navigation buttons
     */
    updateNavigationButtons() {
        const prevButton = document.querySelector('.nav-button.prev');
        const nextButton = document.querySelector('.nav-button.next');

        if (prevButton) {
            prevButton.style.display = this.currentStep > 1 ? 'inline-block' : 'none';
        }

        if (nextButton) {
            if (this.currentStep === this.totalSteps) {
                nextButton.textContent = 'Submit Questionnaire';
                nextButton.type = 'submit';
            } else {
                nextButton.textContent = 'Next Step';
                nextButton.type = 'button';
            }
        }
    }

    /**
     * Save step data
     */
    saveStepData(stepNumber) {
        const stepElement = document.querySelector(`.step:nth-child(${stepNumber})`);
        if (!stepElement) return;

        const inputs = stepElement.querySelectorAll('input, select, textarea');
        inputs.forEach(input => {
            if (input.name) {
                if (input.type === 'checkbox') {
                    this.formData[input.name] = input.checked;
                } else if (input.type === 'radio') {
                    if (input.checked) {
                        this.formData[input.name] = input.value;
                    }
                } else {
                    this.formData[input.name] = input.value;
                }
            }
        });

        // Save to localStorage
        localStorage.setItem('questionnaireData', JSON.stringify(this.formData));
    }

    /**
     * Load step data
     */
    loadStepData() {
        const savedData = localStorage.getItem('questionnaireData');
        if (savedData) {
            try {
                this.formData = JSON.parse(savedData);
                this.populateForm();
            } catch (e) {
                console.warn('Could not parse saved questionnaire data');
            }
        }
    }

    /**
     * Populate form with saved data
     */
    populateForm() {
        Object.keys(this.formData).forEach(name => {
            const field = document.querySelector(`[name="${name}"]`);
            if (!field) return;

            if (field.type === 'checkbox') {
                field.checked = this.formData[name];
            } else if (field.type === 'radio') {
                if (field.value === this.formData[name]) {
                    field.checked = true;
                }
            } else {
                field.value = this.formData[name];
            }
        });
    }

    /**
     * Handle form submission
     */
    async handleSubmit() {
        if (this.isSubmitting) return;

        // Validate final step
        if (!this.validateStep(this.currentStep)) {
            this.showStepError('Please complete all required fields');
            return;
        }

        // Save final step data
        this.saveStepData(this.currentStep);

        this.isSubmitting = true;
        this.setSubmitButtonLoading(true);

        try {
            // Submit form data
            const response = await this.submitForm();
            
            if (response.success) {
                this.handleSubmissionSuccess(response);
            } else {
                this.showStepError(response.error || 'Submission failed. Please try again.');
            }
        } catch (error) {
            console.error('Submission error:', error);
            this.showStepError('Submission failed. Please try again.');
        } finally {
            this.isSubmitting = false;
            this.setSubmitButtonLoading(false);
        }
    }

    /**
     * Submit form data
     */
    async submitForm() {
        const response = await fetch('/api/questionnaire', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(this.formData)
        });

        return await response.json();
    }

    /**
     * Handle successful submission
     */
    handleSubmissionSuccess(response) {
        // Track successful submission
        if (typeof gtag !== 'undefined') {
            gtag('event', 'form_submission', {
                'event_category': 'engagement',
                'event_label': 'questionnaire_complete',
                'value': 1
            });
        }

        // Clear saved data
        localStorage.removeItem('questionnaireData');

        // Redirect to checkout
        window.location.href = 'checkout/payment.html';
    }

    /**
     * Set submit button loading state
     */
    setSubmitButtonLoading(loading) {
        const submitButton = document.querySelector('.nav-button.next[type="submit"]');
        if (!submitButton) return;

        if (loading) {
            submitButton.disabled = true;
            submitButton.classList.add('loading');
            submitButton.textContent = 'Submitting...';
        } else {
            submitButton.disabled = false;
            submitButton.classList.remove('loading');
            submitButton.textContent = 'Submit Questionnaire';
        }
    }

    /**
     * Show step error
     */
    showStepError(message) {
        // Remove existing error messages
        const existingErrors = document.querySelectorAll('.message.error');
        existingErrors.forEach(error => error.remove());

        // Create new error message
        const errorDiv = document.createElement('div');
        errorDiv.className = 'message error';
        errorDiv.textContent = message;

        // Insert at top of current step
        const currentStepElement = document.querySelector('.step.active');
        if (currentStepElement) {
            currentStepElement.insertBefore(errorDiv, currentStepElement.firstChild);
        }

        // Scroll to error
        errorDiv.scrollIntoView({ behavior: 'smooth' });
    }

    /**
     * Setup data persistence
     */
    setupDataPersistence() {
        this.loadStepData();
        
        // Auto-save on input change
        const inputs = document.querySelectorAll('input, select, textarea');
        inputs.forEach(input => {
            input.addEventListener('input', () => {
                this.saveStepData(this.currentStep);
            });
        });
    }

    /**
     * Setup legal disclaimer
     */
    setupLegalDisclaimer() {
        const disclaimerBanner = document.querySelector('.legal-disclaimer-banner');
        if (!disclaimerBanner) return;

        // Add click handler to dismiss disclaimer
        disclaimerBanner.addEventListener('click', () => {
            disclaimerBanner.style.display = 'none';
        });

        // Auto-hide after 10 seconds
        setTimeout(() => {
            disclaimerBanner.style.opacity = '0.7';
        }, 10000);
    }

    /**
     * Track step completion
     */
    trackStepCompletion(stepNumber) {
        if (typeof gtag !== 'undefined') {
            gtag('event', 'questionnaire_step', {
                'event_category': 'engagement',
                'event_label': `step_${stepNumber}_complete`,
                'value': stepNumber
            });
        }
    }
}

/**
 * Initialize questionnaire module when DOM is loaded
 */
document.addEventListener('DOMContentLoaded', () => {
    new QuestionnaireModule();
});

/**
 * Export for use in other modules
 */
if (typeof module !== 'undefined' && module.exports) {
    module.exports = QuestionnaireModule;
}
